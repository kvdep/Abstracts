---
aliases:
  - метод Гаусса
  - Gaussian elimination
---
# Метод Гаусса

**Метод Гаусса** — это классический прямой метод решения [[Система линейных алгебраических уравнений|системы линейных алгебраических уравнений (СЛАУ)]]. Он заключается в последовательном исключении переменных, приводя матрицу системы к треугольному или ступенчатому виду, из которого решение легко находится обратным ходом.

Это один из самых распространённых и эффективных прямых методов для решения [[Система линейных алгебраических уравнений|СЛАУ]] на практике.

## Основная идея

Метод состоит из двух основных этапов:

1.  **Прямой ход (Forward Elimination):** С помощью элементарных преобразований над строками расширенной матрицы системы, её приводят к верхнетреугольному (или ступенчатому) виду. Цель — обнулить все элементы под главной диагональю.
    *   **Элементарные преобразования:**
        1.  Перестановка двух строк.
        2.  Умножение строки на ненулевое число.
        3.  Прибавление к одной строке другой, умноженной на число.

2.  **Обратный ход (Backward Substitution):** Из полученной треугольной системы последовательно, начиная с последней переменной, находят все остальные.

## Алгоритм

Рассмотрим [[Система линейных алгебраических уравнений|СЛАУ]] $Ax=b$ и её расширенную матрицу $[A|b]$.

### 1. Прямой ход

Для каждого столбца $k$ от 0 до $n-1$:
*   **Выбор главного элемента (пивота):** Находится максимальный по модулю элемент в $k$-м столбце, начиная с $k$-й строки. Строка с этим элементом меняется местами с $k$-й строкой. Это делается для повышения численной устойчивости и избежания деления на ноль или близкое к нулю число.
*   **Исключение переменных:** Для всех строк $i$ ниже $k$-й ($i > k$) вычисляется множитель $m = a_{ik} / a_{kk}$. Затем из $i$-й строки вычитается $k$-я строка, умноженная на $m$. В результате элемент $a_{ik}$ становится равным нулю.

После завершения прямого хода матрица $A$ становится верхнетреугольной.

### 2. Обратный ход

Решение находится из полученной треугольной системы, двигаясь снизу вверх:
*   Из последнего уравнения $a_{n-1, n-1}x_{n-1} = b_{n-1}$ находится $x_{n-1}$.
*   Это значение подставляется в предпоследнее уравнение, из которого находится $x_{n-2}$.
*   Процесс продолжается до тех пор, пока не будет найдена первая переменная $x_0$.

Общая формула для обратного хода:
$$
x_i = \frac{1}{a_{ii}} \left( b_i - \sum_{j=i+1}^{n-1} a_{ij}x_j \right) \quad \text{для } i = n-1, n-2, \dots, 0
$$

## Сложность

*   **Время:** $O(n^3)$. Сложность определяется в основном тройным вложенным циклом на этапе прямого хода.
*   **Память:** $O(n^2)$ для хранения расширенной матрицы.

## Пример реализации на Python

```python
import numpy as np

def gaussian_elimination(A, b):
    """
    Реализация метода Гаусса с выбором главного элемента по столбцу.

    Args:
        A (np.ndarray): Квадратная матрица коэффициентов (n x n).
        b (np.ndarray): Вектор свободных членов (n x 1).

    Returns:
        np.ndarray: Вектор решения или None, если нет единственного решения.
    """
    n = len(b)
    # Создаем расширенную матрицу
    Ab = np.hstack([A.astype(float), b.reshape(-1, 1).astype(float)])

    # --- Прямой ход ---
    for i in range(n):
        # Выбор главного элемента (пивота)
        pivot_row = i + np.argmax(np.abs(Ab[i:, i]))
        if np.isclose(Ab[pivot_row, i], 0):
            print("Ошибка: Нет единственного решения (матрица вырождена).")
            return None
        
        # Перестановка строк
        Ab[[i, pivot_row]] = Ab[[pivot_row, i]]

        # Исключение переменных в столбце i
        for j in range(i + 1, n):
            factor = Ab[j, i] / Ab[i, i]
            Ab[j, i:] -= factor * Ab[i, i:]

    # --- Обратный ход ---
    x = np.zeros(n)
    for i in range(n - 1, -1, -1):
        sum_ax = np.dot(Ab[i, i + 1:n], x[i + 1:n])
        x[i] = (Ab[i, n] - sum_ax) / Ab[i, i]

    return x

if __name__ == '__main__':
    # 3x + 2y - z = 1
    # 2x - 2y + 5z = -11
    # -x + y + z = 0
    A = np.array([[3, 2, -1], [2, -2, 5], [-1, 1, 1]], dtype=float)
    b = np.array([1, -11, 0], dtype=float)

    solution = gaussian_elimination(A, b)

    if solution is not None:
        print(f"Решение системы: {solution}")
        # Ожидаемый результат: [ 2. -3. -1.]
        print(f"Проверка A*x: {np.dot(A, solution)}")

    print("-" * 30)
    
    # Пример с вырожденной матрицей
    A_singular = np.array([[1, 1], [2, 2]], dtype=float)
    b_singular = np.array([3, 6], dtype=float)
    gaussian_elimination(A_singular, b_singular)

```