---
aliases:
  - метод Зейделя
  - Gauss-Seidel method
---
# Метод Зейделя

**Метод Зейделя** (или метод Гаусса — Зейделя) — это итерационный численный метод для решения [[Система линейных алгебраических уравнений|системы линейных алгебраических уравнений (СЛАУ)]], а также [[Система нелинейных уравнений|систем нелинейных уравнений (СНУ)]].

Этот метод является модификацией [[Метод простой итерации|метода простой итерации]]. Его ключевое отличие и преимущество заключается в том, что на каждом шаге итерации для вычисления очередной компоненты вектора решения используются уже вычисленные на **текущей** итерации значения других компонент. Это часто приводит к более быстрой сходимости.

## Метод Зейделя для систем линейных уравнений

Рассмотрим [[Система линейных алгебраических уравнений|СЛАУ]] вида $Ax = b$. Как и в [[Метод простой итерации|методе простой итерации]], мы выражаем каждую переменную $x_i$ из $i$-го уравнения:
$$
x_i = \frac{1}{a_{ii}} \left( b_i - \sum_{j \neq i} a_{ij}x_j \right)
$$

### Основная идея

В отличие от метода Якоби (линейный вариант метода простой итерации), где для вычисления всего вектора $x^{(k+1)}$ используется только вектор с предыдущей итерации $x^{(k)}$, метод Зейделя использует уже обновленные компоненты.

При вычислении $x_i^{(k+1)}$ мы используем значения $x_1^{(k+1)}, \dots, x_{i-1}^{(k+1)}$, которые уже были вычислены на **текущей** $(k+1)$-й итерации, и значения $x_{i+1}^{(k)}, \dots, x_n^{(k)}$ с **предыдущей** $k$-й итерации.

### Итерационная формула

Для $i = 1, 2, \dots, n$:
$$
x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j=1}^{i-1} a_{ij}x_j^{(k+1)} - \sum_{j=i+1}^{n} a_{ij}x_j^{(k)} \right)
$$

Итерационный процесс продолжается до тех пор, пока разница между последовательными приближениями не станет меньше заданной точности $\varepsilon$:
$$
\max_i |x_i^{(k+1)} - x_i^{(k)}| < \varepsilon
$$

### Условия сходимости

Достаточным условием сходимости метода Зейделя (как и метода Якоби) является **строгое диагональное преобладание** матрицы $A$:
$$
|a_{ii}| > \sum_{j \neq i} |a_{ij}| \quad \text{для всех } i=1, \dots, n
$$
Если это условие выполнено, метод сходится к единственному решению при любом начальном приближении $x^{(0)}$.

## Метод Зейделя для систем нелинейных уравнений

Для [[Система нелинейных уравнений|СНУ]], приведенной к виду $x = \phi(x)$, метод Зейделя также является модификацией [[Метод простой итерации|метода простой итерации]].

### Итерационная формула

$$
x_i^{(k+1)} = \phi_i(x_1^{(k+1)}, \dots, x_{i-1}^{(k+1)}, x_i^{(k)}, \dots, x_n^{(k)})
$$

Здесь, как и в линейном случае, для вычисления $x_i^{(k+1)}$ используются самые "свежие" значения других переменных. Это может значительно ускорить сходимость по сравнению с обычным методом простой итерации.

## Пример реализации на Python (для СЛАУ)

```python
import numpy as np

def seidel_method(A, b, x0=None, tol=1e-6, max_iter=1000):
    """
    Реализация метода Зейделя для решения СЛАУ Ax = b.

    Args:
        A (np.ndarray): Матрица коэффициентов (n x n).
        b (np.ndarray): Вектор свободных членов (n x 1).
        x0 (np.ndarray, optional): Начальное приближение. Если None, используется нулевой вектор.
        tol (float): Точность решения.
        max_iter (int): Максимальное количество итераций.

    Returns:
        (np.ndarray, int): Кортеж (вектор решения, количество итераций).
                           Возвращает (None, -1) если метод не сошелся.
    """
    n = len(b)
    x = np.zeros(n) if x0 is None else np.copy(x0)

    for k in range(max_iter):
        x_old = np.copy(x)
        
        for i in range(n):
            # Сумма с уже обновленными компонентами x_j^{(k+1)}
            sum1 = np.dot(A[i, :i], x[:i])
            # Сумма с компонентами с прошлой итерации x_j^{(k)}
            sum2 = np.dot(A[i, i + 1:], x_old[i + 1:])
            
            if A[i, i] == 0:
                print("Ошибка: Нулевой диагональный элемент.")
                return None, -1

            x[i] = (b[i] - sum1 - sum2) / A[i, i]

        # Проверка на сходимость
        if np.linalg.norm(x - x_old, ord=np.inf) < tol:
            return x, k + 1

    print("Метод не сошелся за максимальное количество итераций.")
    return x, max_iter

if __name__ == '__main__':
    # Пример системы с диагональным преобладанием
    # 10x1 -  x2 + 2x3 = 6
    # -x1 + 11x2 -  x3 + 3x4 = 25
    # 2x1 -  x2 + 10x3 -  x4 = -11
    #       3x2 -  x3 + 8x4 = 15
    A = np.array([[10, -1, 2, 0],
                  [-1, 11, -1, 3],
                  [2, -1, 10, -1],
                  [0, 3, -1, 8]], dtype=float)
    b = np.array([6, 25, -11, 15], dtype=float)

    solution, iterations = seidel_method(A, b)

    if solution is not None:
        print(f"Решение найдено за {iterations} итераций:")
        print(solution)
        # Ожидаемый результат: [ 1.  2. -1.  1.]
        print("\nПроверка A*x:")
        print(np.dot(A, solution))

```