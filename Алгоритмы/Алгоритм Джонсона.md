---
aliases:
  - алгоритм Джонсона
  - Johnson's algorithm
---
# Алгоритм Джонсона

**Алгоритм Джонсона** — это эффективный алгоритм для нахождения кратчайших путей между **всеми парами вершин** во взвешенном ориентированном [[Граф|графе]]. Его ключевое преимущество заключается в том, что он может работать с рёбрами, имеющими **отрицательный вес**, при условии отсутствия циклов с отрицательным весом.

Для разреженных графов он асимптотически быстрее, чем [[Алгоритм Флойда — Уоршелла]].

## Основная идея

[[Алгоритм Дейкстры]] не работает с рёбрами отрицательного веса. Основная идея алгоритма Джонсона — выполнить **перевзвешивание рёбер (reweighting)** таким образом, чтобы все веса стали неотрицательными, но при этом кратчайшие пути в [[Граф|графе]] сохранились. После этого можно безопасно применить [[Алгоритм Дейкстры|алгоритм Дейкстры]] для каждой вершины.

Процесс перевзвешивания выполняется с помощью **алгоритма Беллмана — Форда**.

## Алгоритм

Алгоритм состоит из трёх основных шагов:

1.  **Шаг 1: Поиск потенциалов с помощью Беллмана — Форда.**
    *   В исходный [[Граф]] $G$ добавляется новая вершина $s$.
    *   Из новой вершины $s$ проводятся рёбра ко всем остальным вершинам [[Граф|графа]] с весом 0.
    *   Запускается алгоритм Беллмана — Форда из вершины $s$. В результате для каждой вершины $v$ вычисляется кратчайшее расстояние от $s$ до $v$, которое мы обозначим как "потенциал" $h(v)$.
    *   Если на этом шаге Беллман — Форд обнаруживает цикл отрицательного веса, алгоритм завершается, так как задача не имеет решения.

2.  **Шаг 2: Перевзвешивание рёбер.**
    *   Новая вершина $s$ и рёбра из неё удаляются.
    *   Вес каждого ребра $(u, v)$ в исходном [[Граф|графе]] изменяется по формуле:
        $$ w'(u, v) = w(u, v) + h(u) - h(v) $$
    *   Благодаря свойству кратчайших путей (неравенство треугольника: $h(v) \le h(u) + w(u, v)$), новый вес $w'(u, v)$ гарантированно будет неотрицательным.

3.  **Шаг 3: Запуск [[Алгоритм Дейкстры|алгоритма Дейкстры]] для всех вершин.**
    *   Для каждой вершины $u$ из исходного [[Граф|графа]] запускается [[Алгоритм Дейкстры|алгоритм Дейкстры]] на [[Граф|графе]] с новыми весами $w'$. Это позволяет найти кратчайшие пути $d'(u, v)$ от $u$ ко всем остальным вершинам $v$.
    *   Итоговое расстояние в исходном [[Граф|графе]] восстанавливается по формуле:
        $$ d(u, v) = d'(u, v) - h(u) + h(v) $$

## Сложность

*   **Время:**
    *   Шаг 1 (Беллман — Форд): $O(|V| \cdot |E|)$.
    *   Шаг 2 (Перевзвешивание): $O(|E|)$.
    *   Шаг 3 ([[Алгоритм Дейкстры|Дейкстра]] для каждой вершины): $O(|V| \cdot |E| \log |V|)$ при использовании двоичной кучи.
    *   **Итоговая сложность:** $O(|V| \cdot |E| \log |V|)$. Для разреженных графов это значительно лучше, чем $O(|V|^3)$ у алгоритма Флойда — Уоршелла.

*   **Память:** $O(|V|^2)$ для хранения матрицы расстояний.

## Пример реализации на Python

Вот пример реализации алгоритма на Python. Для простоты [[Алгоритм Дейкстры|алгоритм Дейкстры]] реализован без очереди с приоритетом, что даёт сложность $O(|V|^2)$ для одного запуска.

```python
import sys

def johnson(graph):
    """
    Реализация алгоритма Джонсона для поиска кратчайших путей между всеми парами вершин.

    Args:
        graph: Граф, представленный как словарь.
               Ключи - вершины, значения - словари смежных вершин с весами рёбер.
               Пример: {'A': {'B': 3, 'C': 8}, 'B': {'C': 1}}

    Returns:
        Словарь словарей с кратчайшими расстояниями между всеми парами вершин
        или None, если в графе есть цикл отрицательного веса.
    """
    vertices = list(graph.keys())
    
    # --- Шаг 1: Добавление новой вершины и запуск Беллмана-Форда ---
    temp_graph = {v: graph[v].copy() for v in vertices}
    temp_vertex = 's_temp'
    temp_graph[temp_vertex] = {v: 0 for v in vertices}

    # Инициализация расстояний
    h = {v: float('inf') for v in temp_graph}
    h[temp_vertex] = 0

    # Релаксация рёбер |V| - 1 раз
    for _ in range(len(temp_graph) - 1):
        for u in temp_graph:
            for v, weight in temp_graph[u].items():
                if h[u] != float('inf') and h[u] + weight < h[v]:
                    h[v] = h[u] + weight

    # Проверка на наличие циклов отрицательного веса
    for u in temp_graph:
        for v, weight in temp_graph[u].items():
            if h[u] != float('inf') and h[u] + weight < h[v]:
                print("Ошибка: Граф содержит цикл отрицательного веса.")
                return None
    
    del h[temp_vertex] # Удаляем потенциал для временной вершины

    # --- Шаг 2: Перевзвешивание графа ---
    reweighted_graph = {u: {} for u in vertices}
    for u in graph:
        for v, weight in graph[u].items():
            reweighted_graph[u][v] = weight + h[u] - h[v]

    # --- Шаг 3: Запуск Дейкстры для каждой вершины ---
    all_pairs_shortest_paths = {u: {} for u in vertices}

    for start_node in vertices:
        # Простая реализация Дейкстры
        dist = {v: float('inf') for v in vertices}
        dist[start_node] = 0
        unvisited = set(vertices)

        while unvisited:
            current_node = min(unvisited, key=lambda v: dist[v])
            unvisited.remove(current_node)

            if dist[current_node] == float('inf'):
                break

            for neighbor, weight in reweighted_graph.get(current_node, {}).items():
                new_dist = dist[current_node] + weight
                if new_dist < dist[neighbor]:
                    dist[neighbor] = new_dist
        
        # Восстановление исходных расстояний
        for v in vertices:
            if dist[v] != float('inf'):
                all_pairs_shortest_paths[start_node][v] = dist[v] - h[start_node] + h[v]
            else:
                all_pairs_shortest_paths[start_node][v] = float('inf')

    return all_pairs_shortest_paths


if __name__ == '__main__':
    # Пример графа с отрицательными весами
    example_graph = {
        'A': {'B': -2},
        'B': {'C': -1},
        'C': {'A': 4, 'D': 2, 'E': -3},
        'D': {},
        'E': {'D': 1}
    }

    shortest_paths = johnson(example_graph)

    if shortest_paths:
        for start_node in sorted(shortest_paths.keys()):
            print(f"Кратчайшие пути из вершины {start_node}:")
            for end_node in sorted(shortest_paths[start_node].keys()):
                distance = shortest_paths[start_node][end_node]
                print(f"  до {end_node}: {distance}")
            print("-" * 20)