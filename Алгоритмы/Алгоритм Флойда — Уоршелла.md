---
aliases:
  - алгоритм Флойда — Уоршелла
  - Floyd-Warshall algorithm
  - алгоритм Флойда
---
# Алгоритм Флойда — Уоршелла

**Алгоритм Флойда — Уоршелла** — это алгоритм динамического программирования для нахождения кратчайших путей между **всеми парами вершин** во взвешенном ориентированном [[Граф|графе]]. Он способен корректно работать с рёбрами **отрицательного веса**, а также обнаруживать циклы отрицательного веса.

Для плотных графов он может быть эффективнее, чем многократный запуск [[Алгоритм Дейкстры|алгоритма Дейкстры]] или [[Алгоритм Джонсона|алгоритм Джонсона]].

## Основная идея

В основе алгоритма лежит принцип динамического программирования. Идея состоит в том, чтобы итеративно улучшать оценку кратчайшего пути между двумя вершинами `i` и `j`, разрешая использовать в качестве промежуточных вершин некоторый набор вершин.

Пусть `dist[i][j]` — это длина кратчайшего пути от `i` до `j`. На шаге `k` алгоритм проверяет, можно ли сократить путь из `i` в `j`, пройдя через вершину `k`.

Ключевая формула обновления выглядит так:
$$
dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])
$$

Этот процесс повторяется для всех возможных промежуточных вершин `k` (от 1 до `|V|`), что гарантирует нахождение оптимального пути, использующего любое подмножество вершин графа.

## Алгоритм

1.  **Шаг 1: Инициализация матрицы расстояний.**
    *   Создаётся матрица смежности `dist` размером $|V| \times |V|$.
    *   Для каждой пары вершин `(i, j)`:
        *   Если `i == j`, то `dist[i][j] = 0`.
        *   Если существует ребро из `i` в `j`, то `dist[i][j]` равно весу этого ребра.
        *   Если ребра нет, `dist[i][j] = \infty`.

2.  **Шаг 2: Основной цикл.**
    *   Выполняются три вложенных цикла для перебора всех возможных пар вершин `(i, j)` и всех возможных промежуточных вершин `k`.
    ```
    for k from 1 to |V|:
        for i from 1 to |V|:
            for j from 1 to |V|:
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    ```

3.  **Шаг 3: Проверка на наличие циклов отрицательного веса.**
    *   После завершения основного цикла проверяются диагональные элементы матрицы `dist`.
    *   Если для какой-либо вершины `i` выполняется условие `dist[i][i] < 0`, это означает, что из `i` можно попасть в цикл с отрицательным суммарным весом и вернуться обратно, "уменьшив" расстояние до самого себя. В этом случае задача поиска кратчайших путей не имеет корректного решения.

## Сложность

*   **Время:** $O(|V|^3)$. Сложность определяется тремя вложенными циклами.
*   **Память:** $O(|V|^2)$ для хранения матрицы расстояний.

## Пример реализации на Python

```python
import sys

def floyd_warshall(graph):
    """
    Реализация алгоритма Флойда — Уоршелла.

    Args:
        graph: Граф, представленный матрицей смежности.
               graph[i][j] - вес ребра из i в j.
               Если ребра нет, используется float('inf').

    Returns:
        Матрица кратчайших расстояний или None, если есть цикл отрицательного веса.
    """
    num_vertices = len(graph)
    dist = [row[:] for row in graph] # Копируем матрицу

    # Основной цикл
    for k in range(num_vertices):
        for i in range(num_vertices):
            for j in range(num_vertices):
                if dist[i][k] != float('inf') and dist[k][j] != float('inf'):
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    # Проверка на циклы отрицательного веса
    for i in range(num_vertices):
        if dist[i][i] < 0:
            print("Ошибка: Граф содержит цикл отрицательного веса.")
            return None

    return dist

if __name__ == '__main__':
    INF = float('inf')
    # Пример графа в виде матрицы смежности
    #       A, B,  C,  D
    graph = [[0, 3, INF, 5],   # A
             [2, 0, INF, 4],   # B
             [INF, 1, 0, INF], # C
             [INF, INF, 2, 0]]  # D

    shortest_paths = floyd_warshall(graph)

    if shortest_paths:
        print("Матрица кратчайших расстояний:")
        for row in shortest_paths:
            print([f"{d:.0f}" if d != INF else "INF" for d in row])

    # Ожидаемый результат:
    # ['0', '3', '7', '5']
    # ['2', '0', '6', '4']
    # ['3', '1', '0', '5']
    # ['5', '3', '2', '0']
```