---
aliases:
  - UMAP
  - Uniform Manifold Approximation and Projection
---
# UMAP (Uniform Manifold Approximation and Projection)

**UMAP (Uniform Manifold Approximation and Projection)** — это современный алгоритм нелинейного понижения размерности, который, как и [[t-SNE]], используется для визуализации многомерных данных и извлечения признаков.

UMAP часто превосходит [[t-SNE]] как по скорости работы, так и по качеству получаемого вложения, поскольку он лучше сохраняет не только **локальную**, но и **глобальную** структуру данных.

## Основная идея

В основе UMAP лежат сложные математические концепции из римановой геометрии и алгебраической топологии. Упрощённо, его работу можно описать в два этапа:

1.  **Построение топологической структуры в исходном пространстве:**
    *   Для каждой точки UMAP находит её ближайших соседей.
    *   На основе этих соседств строится взвешенный граф, где веса рёбер отражают "вероятность" того, что две точки соединены на многообразии, на котором, как предполагается, лежат данные. Этот граф представляет собой упрощённую топологическую модель данных.

2.  **Поиск аналогичной структуры в низкоразмерном пространстве:**
    *   Алгоритм пытается найти такое расположение точек на плоскости (или в 3D), которое имеет максимально похожую топологическую структуру.
    *   Оптимизация происходит путём минимизации **кросс-энтропии** между взвешенными графами в исходном и целевом пространствах. Это заставляет связанные точки притягиваться, а несвязанные — отталкиваться.

## Ключевые гиперпараметры

*   **`n_neighbors` (количество соседей):** Самый важный параметр, аналог `perplexity` в [[t-SNE]]. Он определяет, насколько локально или глобально UMAP будет "смотреть" на данные.
    *   Маленькие значения (2-15) заставляют алгоритм фокусироваться на очень локальной структуре, выделяя мелкие кластеры.
    *   Большие значения (50-200) позволяют UMAP увидеть более глобальную картину, объединяя мелкие кластеры в более крупные структуры.
*   **`min_dist` (минимальное расстояние):** Контролирует, насколько плотно UMAP будет упаковывать точки в кластеры.
    *   Маленькие значения (0.0-0.1) создают очень плотные, компактные кластеры.
    *   Большие значения (0.5-0.99) позволяют точкам "расползаться", что лучше показывает топологическую структуру внутри кластеров, но делает их менее чёткими.
*   **`metric` (метрика):** Метрика расстояния, используемая для поиска соседей в исходном пространстве (например, `euclidean`, `cosine`, `manhattan`).

## Сравнение с t-SNE

| Признак | [[t-SNE]] | UMAP |
| :--- | :--- | :--- |
| **Теория** | Вероятностная | **Топологическая** (риманова геометрия) |
| **Структура** | Сохраняет только **локальную** структуру | Сохраняет **локальную и глобальную** структуру |
| **Скорость** | Медленный ($O(N^2)$ или $O(N \log N)$ с оптимизациями) | **Очень быстрый**, хорошо масштабируется |
| **Интерпретация** | Расстояния между кластерами неинформативны | Расстояния между кластерами **лучше отражают** реальную "удалённость" в данных |
| **Параметры** | `perplexity` (сложен в настройке) | `n_neighbors`, `min_dist` (более интуитивны) |
| **Применение** | Только для вложения (визуализации) | Может использоваться для **преобразования новых данных** (как `transform` в Scikit-learn) |

**Вывод:** В большинстве случаев UMAP является предпочтительным выбором по сравнению с [[t-SNE]] из-за его скорости, лучшего сохранения глобальной структуры и более гибкой настройки.

## Пример на Python (с использованием `umap-learn`)

Сравним UMAP и [[t-SNE]] на наборе данных `digits`.

```python
import numpy as np
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE
from sklearn.datasets import load_digits
import umap # pip install umap-learn
import time

def umap_vs_tsne_visualization():
    """
    Сравнение UMAP и t-SNE на наборе данных рукописных цифр.
    """
    # 1. Загрузка данных
    digits = load_digits()
    X = digits.data
    y = digits.target

    # 2. Применение UMAP
    start_time = time.time()
    reducer = umap.UMAP(n_neighbors=30, min_dist=0.1, random_state=42)
    X_umap = reducer.fit_transform(X)
    umap_time = time.time() - start_time

    # 3. Применение t-SNE
    start_time = time.time()
    tsne = TSNE(n_components=2, perplexity=30, init='pca', random_state=42, learning_rate='auto')
    X_tsne = tsne.fit_transform(X)
    tsne_time = time.time() - start_time

    # 4. Визуализация
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 8))

    # График UMAP
    scatter1 = ax1.scatter(X_umap[:, 0], X_umap[:, 1], c=y, cmap=plt.cm.get_cmap("jet", 10), alpha=0.7)
    ax1.set_title(f'UMAP (время: {umap_time:.2f} с)', fontsize=14)
    ax1.set_xlabel('UMAP компонента 1')
    ax1.set_ylabel('UMAP компонента 2')
    ax1.grid(True, linestyle='--', alpha=0.5)

    # График t-SNE
    scatter2 = ax2.scatter(X_tsne[:, 0], X_tsne[:, 1], c=y, cmap=plt.cm.get_cmap("jet", 10), alpha=0.7)
    ax2.set_title(f't-SNE (время: {tsne_time:.2f} с)', fontsize=14)
    ax2.set_xlabel('t-SNE компонента 1')
    ax2.set_ylabel('t-SNE компонента 2')
    ax2.grid(True, linestyle='--', alpha=0.5)

    # Общая легенда
    fig.legend(handles=scatter1.legend_elements()[0], labels=list(range(10)), title="Цифры", loc='center right')
    plt.suptitle('Сравнение UMAP и t-SNE на наборе данных "digits"', fontsize=16)
    plt.subplots_adjust(right=0.9)
    plt.show()

    print(f"UMAP выполнился в {tsne_time / umap_time:.2f} раз быстрее, чем t-SNE.")

if __name__ == '__main__':
    # Для корректной работы umap может потребоваться установка llvmlite:
    # pip install llvmlite
    # pip install umap-learn[plot]
    umap_vs_tsne_visualization()

```

На графиках видно, что оба метода хорошо разделяют кластеры, но UMAP делает это значительно быстрее и часто создаёт более осмысленное глобальное расположение кластеров.
