---
aliases:
  - QR-разложение
  - QR-декомпозиция
  - QR decomposition
---
# QR-разложение

**QR-разложение (QR-декомпозиция)** — это представление матрицы $A$ (не обязательно квадратной) в виде произведения ортогональной (или унитарной) матрицы $Q$ и верхней треугольной матрицы $R$.
$$
A = QR
$$
где:
*   $Q$ — ортогональная матрица ($Q^T Q = I$, где $I$ — единичная матрица).
*   $R$ — верхняя треугольная матрица.

Это разложение является основой для многих численных алгоритмов, в частности для решения [[Система линейных алгебраических уравнений|СЛАУ]], решения задачи наименьших квадратов и вычисления собственных значений (QR-алгоритм).

## Основная идея

Идея QR-разложения заключается в ортогонализации столбцов матрицы $A$. Процесс, аналогичный **ортогонализации Грама-Шмидта**, преобразует исходный набор векторов-столбцов $A$ в новый ортонормированный [[Базис]]. Этот новый [[Базис]] и составляет столбцы матрицы $Q$. Матрица $R$ при этом хранит коэффициенты, которые позволяют выразить исходные столбцы $A$ через новый [[Базис]].

### Применение для решения СЛАУ

Для решения системы $Ax=b$:
1.  Подставляем $A=QR$: $QRx = b$.
2.  Умножаем обе части слева на $Q^T$: $Q^T Q R x = Q^T b$.
3.  Так как $Q^T Q = I$, получаем: $Rx = Q^T b$.

В итоге мы получаем систему с верхней треугольной матрицей $R$, которая легко решается **обратным ходом**. Этот метод численно более устойчив, чем [[Метод Гаусса]] или [[LU-разложение]].

### Применение для метода наименьших квадратов (МНК)

QR-разложение особенно эффективно для решения переопределенных систем ($m > n$), где нужно минимизировать норму невязки $\|Ax - b\|^2$. Решение [[Метод наименьших квадратов|МНК]] находится из нормального уравнения $A^T A x = A^T b$.

Подстановка $A=QR$ значительно упрощает задачу:
$$
(QR)^T(QR)x = (QR)^T b \implies R^T Q^T Q R x = R^T Q^T b \implies R^T R x = R^T Q^T b
$$
Если $A$ имеет полный ранг, то $R$ обратима, и уравнение сводится к $Rx = Q^T b$, что избегает вычисления $A^T A$ и связанных с этим проблем численной устойчивости.

## Алгоритмы нахождения

Существует несколько методов для вычисления QR-разложения:
1.  **Процесс Грама-Шмидта:** Классический, но численно неустойчивый метод.
2.  **Преобразования Хаусхолдера (отражения):** Более сложный, но численно устойчивый и широко используемый на практике.
3.  **Преобразования Гивенса (вращения):** Эффективен для разреженных матриц.

## Сложность

*   **Сложность разложения (методом Хаусхолдера):** $O(m n^2)$ для матрицы $m \times n$. Для квадратной матрицы — $O(n^3)$.
*   **Сложность решения [[Система линейных алгебраических уравнений|СЛАУ]]:** После разложения решение требует $O(n^2)$ операций.

## Пример реализации на Python

В `numpy.linalg` есть готовая функция `qr`, которая эффективно реализует этот метод, как правило, с использованием преобразований Хаусхолдера.

```python
import numpy as np

def solve_with_qr(A, b):
    """
    Решение СЛАУ Ax=b с использованием QR-разложения из NumPy.
    Подходит как для квадратных, так и для переопределенных систем (МНК).

    Args:
        A (np.ndarray): Матрица коэффициентов (m x n).
        b (np.ndarray): Вектор свободных членов (m x 1).

    Returns:
        np.ndarray: Вектор решения x.
    """
    m, n = A.shape

    # Шаг 1: Выполняем QR-разложение A = QR
    Q, R = np.linalg.qr(A)

    # Шаг 2: Вычисляем правую часть Q^T * b
    # Q.T - это сопряженно-транспонированная матрица. Для вещественных матриц это Q^T.
    QTb = np.dot(Q.T, b)

    # Шаг 3: Решаем систему Rx = Q^T * b обратным ходом.
    # Так как R может быть неквадратной (m x n), берем ее квадратную часть n x n.
    x = np.zeros(n)
    for i in range(n - 1, -1, -1):
        sum_rx = np.dot(R[i, i + 1:], x[i + 1:])
        if np.isclose(R[i, i], 0):
            # Это указывает на линейную зависимость столбцов A
            print("Предупреждение: Матрица может быть вырожденной.")
            # В реальных задачах здесь нужна более сложная обработка
            # (например, использование псевдообратной матрицы)
            continue
        x[i] = (QTb[i] - sum_rx) / R[i, i]

    return x

if __name__ == '__main__':
    # Пример 1: Квадратная система
    print("--- Пример 1: Квадратная система ---")
    A1 = np.array([[3, 2, -1], [2, -2, 5], [-1, 1, 1]], dtype=float)
    b1 = np.array([1, -11, 0], dtype=float)

    solution1 = solve_with_qr(A1, b1)
    print(f"Решение системы: {solution1}")
    # Сравнение с np.linalg.solve
    print(f"Решение np.linalg.solve: {np.linalg.solve(A1, b1)}")
    print(f"Проверка A*x: {np.dot(A1, solution1)}")

    print("\n" + "-"*40 + "\n")

    # Пример 2: Переопределенная система (решение МНК)
    # y = c1*x + c2
    print("--- Пример 2: Переопределенная система (МНК) ---")
    # Точки (x, y): (0, 1), (1, 3), (2, 4), (3, 4)
    A2 = np.array([[0, 1], [1, 1], [2, 1], [3, 1]], dtype=float)
    b2 = np.array([1, 3, 4, 4], dtype=float)

    solution2 = solve_with_qr(A2, b2)
    print(f"Коэффициенты [c1, c2]: {solution2}")
    # Сравнение с np.linalg.lstsq
    solution_lstsq = np.linalg.lstsq(A2, b2, rcond=None)[0]
    print(f"Решение np.linalg.lstsq: {solution_lstsq}")

```