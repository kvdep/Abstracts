---
aliases:
  - LU-разложение
  - LU-декомпозиция
  - LU decomposition
---
# LU-разложение

**LU-разложение (LU-декомпозиция)** — это представление квадратной матрицы $A$ в виде произведения двух матриц: нижней треугольной матрицы $L$ (Lower) и верхней треугольной матрицы $U$ (Upper).
$$
A = LU
$$
Этот метод является основой для эффективного решения [[Система линейных алгебраических уравнений|систем линейных алгебраических уравнений (СЛАУ)]], вычисления обратных матриц и определителей. По сути, LU-разложение — это матричная форма [[Метод Гаусса|метода Гаусса]].

## Основная идея

Основная идея заключается в том, чтобы свести решение одной сложной системы $Ax=b$ к решению двух простых систем с треугольными матрицами.

1.  Исходное уравнение: $Ax = b$.
2.  Подставляем $A = LU$: $LUx = b$.
3.  Вводим вспомогательный вектор $y$, такой что $Ux = y$.
4.  Теперь задача разбивается на два последовательных шага:
    *   **Решить $Ly = b$ относительно $y$.** Эта система легко решается **прямым ходом** (forward substitution), так как матрица $L$ является нижнетреугольной.
    *   **Решить $Ux = y$ относительно $x$.** Эта система легко решается **обратным ходом** (backward substitution), так как матрица $U$ является верхнетреугольной.

Главное преимущество этого подхода проявляется, когда нужно решить несколько [[Система линейных алгебраических уравнений|СЛАУ]] с одной и той же матрицей $A$, но с разными векторами правых частей $b$. Разложение $A=LU$ выполняется один раз, а затем для каждого нового $b$ быстро решаются две треугольные системы.

## Алгоритм

### 1. Нахождение матриц L и U (метод Дулиттла)

Существует несколько способов найти матрицы $L$ и $U$. Один из самых распространённых — **метод Дулиттла**, где диагональные элементы матрицы $L$ равны 1 ($l_{ii}=1$).

Матрицы $L$ и $U$ можно найти итеративно:
*   Элементы $U$ вычисляются по формуле:
    $$ u_{ij} = a_{ij} - \sum_{k=1}^{i-1} l_{ik}u_{kj} \quad (i \le j) $$
*   Элементы $L$ вычисляются по формуле:
    $$ l_{ij} = \frac{1}{u_{jj}} \left( a_{ij} - \sum_{k=1}^{j-1} l_{ik}u_{kj} \right) \quad (i > j) $$

Фактически, матрица $U$ — это та самая верхнетреугольная матрица, которая получается в результате прямого хода [[Метод Гаусса|метода Гаусса]], а в матрице $L$ под главной диагональю хранятся коэффициенты, которые использовались при исключении переменных.

### 2. Решение системы

После получения $L$ и $U$:
*   **Прямой ход:** Находим $y$ из $Ly=b$.
    $$ y_i = b_i - \sum_{j=1}^{i-1} l_{ij}y_j \quad \text{для } i=1, \dots, n $$
*   **Обратный ход:** Находим $x$ из $Ux=y$.
    $$ x_i = \frac{1}{u_{ii}} \left( y_i - \sum_{j=i+1}^{n} u_{ij}x_j \right) \quad \text{для } i=n, \dots, 1 $$

## Сложность и применимость

*   **Сложность разложения:** $O(n^3)$, что сопоставимо с [[Метод Гаусса|методом Гаусса]].
*   **Сложность решения (прямой + обратный ход):** $O(n^2)$.

Это делает метод чрезвычайно эффективным для многократных решений [[Система линейных алгебраических уравнений|СЛАУ]] с постоянной матрицей $A$. Разложение выполняется один раз, а каждое последующее решение требует всего $O(n^2)$ операций.

**Примечание:** Для повышения численной устойчивости на практике используется LU-разложение с частичным выбором ведущего элемента (пивотингом), что соответствует перестановке строк в [[Метод Гаусса|методе Гаусса]]. В этом случае разложение имеет вид $PA=LU$, где $P$ — матрица перестановок.

## Пример реализации на Python

В `scipy.linalg` есть готовая функция `lu_solve`, которая эффективно реализует этот метод.

```python
import numpy as np
from scipy.linalg import lu_factor, lu_solve

def solve_with_lu(A, b):
    """
    Решение СЛАУ Ax=b с использованием LU-разложения из SciPy.

    Args:
        A (np.ndarray): Квадратная матрица коэффициентов (n x n).
        b (np.ndarray): Вектор свободных членов (n x 1).

    Returns:
        np.ndarray: Вектор решения или None в случае ошибки.
    """
    try:
        # Шаг 1: Выполняем PA=LU разложение.
        # lu_factor возвращает матрицы L и U в компактном виде и вектор перестановок.
        lu, piv = lu_factor(A)

        # Шаг 2: Решаем систему Ax=b, используя полученное разложение.
        # lu_solve выполняет прямой и обратный ход.
        x = lu_solve((lu, piv), b)
        
        return x
    except np.linalg.LinAlgError:
        print("Ошибка: Матрица вырождена, LU-разложение невозможно.")
        return None

if __name__ == '__main__':
    # 3x + 2y - z = 1
    # 2x - 2y + 5z = -11
    # -x + y + z = 0
    A = np.array([[3, 2, -1], [2, -2, 5], [-1, 1, 1]], dtype=float)
    b1 = np.array([1, -11, 0], dtype=float)
    b2 = np.array([10, 5, -5], dtype=float)

    print("--- Решение для первого вектора b1 ---")
    solution1 = solve_with_lu(A, b1)
    if solution1 is not None:
        print(f"Решение системы: {solution1}")
        # Ожидаемый результат: [ 2. -3. -1.]
        print(f"Проверка A*x: {np.dot(A, solution1)}")

    print("\n" + "-"*40 + "\n")

    # Преимущество LU: решаем систему с той же матрицей A, но другим вектором b2.
    # Повторное разложение не требуется, что экономит время.
    print("--- Решение для второго вектора b2 ---")
    solution2 = solve_with_lu(A, b2)
    if solution2 is not None:
        print(f"Решение системы: {solution2}")
        print(f"Проверка A*x: {np.dot(A, solution2)}")

```